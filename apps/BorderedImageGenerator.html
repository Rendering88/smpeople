<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oops...</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            transition: color 0.3s linear;
        }

        input#scale {
            width: 500px;
        }

        img {
            max-width: 700px;
        }
    </style>
</head>

<body>
    <div style="margin-bottom: 3px;">
        <div>
            Scale: <input type="range" id="scale" name="scale" min="1" max="100" step="1" value="42"> <input type="text"
                id="scaletext" value="0" style="width: 50px;" readonly>
        </div>
        <div>
            Frame bg-color: <input type="text" id="fbgcolor" value="blue" style="width: 200px;"> (hex, rgba(), html color name)
        </div>
    </div>
    <img id="image" />
    <div>(You can copy to clipboard the image using Ctrl + C.)</div>
    <script>
        class BorderedImageGenerator {
            constructor({ mainSrc, badgeSrc, crossSrc, scale = 25, badgecolor }) {
                this.mainSrc = mainSrc;
                this.badgeSrc = badgeSrc;
                this.crossSrc = crossSrc;
                this.scale = scale;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.badgecolor = badgecolor;
            }

            async loadImages() {
                this.mainImg = await this.loadImage(this.mainSrc);
                this.badgeImg = await this.loadImage(this.badgeSrc);
                this.crossImg = await this.loadImage(this.crossSrc);
            }

            loadImage(src) {
                if(src) return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                })
            }

            draw() {
                if (!this.mainImg || !this.badgeImg) {
                    console.error("Images are not loaded yet!");
                    return;
                }

                const size = this.mainImg.width / 100 * this.scale;
                this.canvas.width = this.mainImg.width + size * 2;
                this.canvas.height = this.mainImg.height + size * 2;

                this.ctx.fillStyle = "blue";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.drawImage(this.mainImg, size, size);

                const cols = Math.floor((this.mainImg.width + size) / size) + 1;
                const rows = Math.floor((this.mainImg.height + size) / size) + 1;

                for (let j = 0; j <= rows; j++) {
                    this.ctx.drawImage(this.badgeImg, 0, j * size, size, size);
                    this.ctx.drawImage(this.badgeImg, this.canvas.width - size, j * size, size, size);
                }
                for (let i = 0; i <= cols; i++) {
                    this.ctx.drawImage(this.badgeImg, i * size, 0, size, size);
                    this.ctx.drawImage(this.badgeImg, i * size, this.canvas.height - size, size, size);
                }

                this.ctx.clearRect(this.canvas.width - size, 0, size, size);
                this.ctx.drawImage(this.crossImg, this.canvas.width - size, 0, size, size);

                this.ctx.fillStyle = "black";
                this.ctx.font = (this.canvas.height / 50).toFixed() + "px Arial";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "bottom";
                this.ctx.fillText(`${this.scale}`, 20, this.canvas.height - 20);
            }

            async generate() {
                return new Promise((resolve, reject) => {
                    this.draw();
                    this.canvas.toBlob(blob => {
                        if (blob) {
                            const blobUrl = URL.createObjectURL(blob);
                            resolve(blobUrl);
                        } else {
                            reject(new Error('Blob creation failed'));
                        }
                    }, 'image/png');
                });
            }

            updateScale(newScale) {
                this.scale = newScale;
            }
            async updatebadge(color) {
                if (this.badgecolor !== color) {
                    this.badgeSrc = await mergeImages("images/f_black.png", "images/m4.png", color);
                    this.badgeImg = await this.loadImage(this.badgeSrc);
                }
            }
            async updateMain(mainSrc) {
                this.mainSrc = mainSrc;
                this.mainImg = await this.loadImage(this.mainSrc);
            }
        }
        async function mergeImages(frameImageSrc, photoImageSrc, backgroundColor = null) {
            return new Promise((resolve, reject) => {
                const frameImg = new Image();
                const photoImg = new Image();
                frameImg.onload = () => {
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    canvas.width = frameImg.width;
                    canvas.height = frameImg.height;
                    if (backgroundColor) {
                        ctx.fillStyle = backgroundColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    photoImg.onload = () => {
                        ctx.drawImage(photoImg, 0, 0, frameImg.width, frameImg.height);
                        ctx.drawImage(frameImg, 0, 0, frameImg.width, frameImg.height);
                        resolve(canvas.toDataURL("image/png"));
                    };
                    photoImg.onerror = reject;
                    photoImg.src = photoImageSrc;
                };
                frameImg.onerror = reject;
                frameImg.src = frameImageSrc;
            });
        }
        const imageset = async () => {
            const image = new BorderedImageGenerator({
                mainSrc: 'images/noimage.jpg',
                badgeSrc: await mergeImages("images/f_black.png", "images/m4.png", document.querySelector('#fbgcolor').value),
                crossSrc: await mergeImages("images/f_black.png", "images/cross1.png", "black"),
                scale: document.querySelector('#scale').value,
                badgecolor: document.querySelector('#fbgcolor').value,
            });
            await image.loadImages();
            document.querySelector('#image').src = await image.generate();

            document.querySelector('#scaletext').value = document.querySelector('#scale').value;
            document.querySelector('#scale').addEventListener('input', async () => {
                document.querySelector('#scaletext').value = document.querySelector('#scale').value;
            });
            document.querySelector('#scale').addEventListener('change', async () => {
                await image.updatebadge(document.querySelector('#fbgcolor').value);
                image.updateScale(document.querySelector('#scale').value);
                document.querySelector('#image').src = await image.generate();
            });
            document.querySelector('#fbgcolor').addEventListener('change', async () => {
                await image.updatebadge(document.querySelector('#fbgcolor').value);
                image.updateScale(document.querySelector('#scale').value);
                document.querySelector('#image').src = await image.generate();
            });
            document.addEventListener('paste', async (event) => {
                const activeElement = document.activeElement;
                const isEditable = (
                    activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable
                );

                if (isEditable) return;

                try {
                    const items = event.clipboardData.items;
                    for (const item of items) {
                        if (item.type.startsWith('image/')) {
                            const blob = item.getAsFile();
                            const url = URL.createObjectURL(blob);
                            await image.updateMain(url);
                            document.querySelector('#image').src = await image.generate();
                            return;
                        }
                    }
                } catch (error) {
                    console.error('An error occurred while pasting an image:', error);
                }
            });
            document.addEventListener('copy', async (event) => {
                const activeElement = document.activeElement;
                const isEditable = (
                    activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable
                );
                if (isEditable) return;

                try {
                    const blob = await new Promise((resolve) => {
                        image.canvas.toBlob(resolve, 'image/png');
                    });
                    const clipboardItem = new ClipboardItem({ 'image/png': blob });
                    await navigator.clipboard.write([clipboardItem]);

                    document.body.setAttribute('style', 'background-color: rgb(174, 230, 248); transition: color 0s;');
                    setTimeout(() => {
                        document.body.setAttribute('style', 'transition: color 0.3s;');
                    }, 300);

                } catch (error) {
                    console.error('An error occurred while copying the image:', error);
                }
            });

        };

        imageset();
    </script>
</body>

</html>